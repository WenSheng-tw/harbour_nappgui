# GTNAP Designer

El objetivo de este documento es realizar una introducción y planificación de la herramienta GTNAP-Designer para el diseño visual de formularios y ventanas de interfaz. En principio, esta pretende ser un "clon" del QT-Designer con algunas diferencias:

* GTNAP-Designer creará formularios compatibles con NAppGUI-SDK.
* Se podrán exportar los resultados a un archivo `.prg`, en lenguaje **Harbour**, por tanto, compilable por `hbmk2`.
* Los formularios serán multiplataforma (Windows, macOS, Linux) y respetarán el _look&feel_ nativo de cada sistema: Colores, Tipografías, Temas, etc.

**QT-Designer**

![QT-Designer](images/qtdesigner.png)

**GTNAP-Designer**

![GTNAP-Designer](images/gtnapdesigner.png)

## Planificación

El desarrollo de una herramienta de este tipo goza de cierta dificultad y es fácil de incurrir en retrasos y callejones sin salida por no delimitar bien los objetivos y funcionalidades. Por esta razón dividiremos el desarrollo en 4 fases:

* Operativa básica (12 Sprints).
* Componentes avanzados (8 Sprints).
* Funciones avanzadas de edición.
* Formularios redimensionables.

## Fase 1: Operativa básica

> **Importante** En esta fase se creará una herramienta básica, con limitadas funcionalidades gráficas e interactivas. El principal objetivo será poder componer formularios básicos y exportarlos a Harbour.

Tras concluir esta fase tendremos:

* Aplicación de escritorio cuya ventana estará dividida en tres áreas bien delimitadas (igual que QtDesigner):
    * Parte izquierda: Zona widgets, donde están los elementos que podemos utilizar para el diseño.
    * Parte central: Canvas de dibujo. Donde diseñaremos los formularios.
    * Parte derecha: Inspector de objetos y propiedades.

* Elementos incluidos (de momento):
    * Layout (Solo grid de momento). El grid permite crear VerticalLayout y HorizontalLayout.
    * Label.
    * Button.
    * CheckBox.
    * EditBox.

* Editor multi-formulario. En lugar de cargar formularios uno a uno, el editor permitirá tener varios archivos abiertos y alternar entre ellos. Algo así como la opción "open folder" de algunos editores que cargará a la vez todos los formularios existentes en una misma carpeta.

* Archivo de diseño **(.ui)**. Archivo con el diseño del formulario que puede abrirse con el editor. Seguramente en formato JSON.

* Exportar a Harbour. Generar un archivo **.prg** con el código Harbour capaz de crear el formulario en tiempo de ejecución.

* Comunicación con el formulario: La aplicación final debe ser capaz de acceder al formulario en tiempo de ejecución: Detectar si se ha pulsado un botón, obtener el texto de un EditBox, etc.

**Diseño de GTNAP-Designer (primera fase)**

![Layout](images/layout.png)


### Fase 1: Estimación de Sprints (12)

* **Sprint 1:** Crear el cuerpo de la aplicación. Ventanas, paneles, layouts y controles.

* **Sprint 2:** Crear en el canvas la jerarquía de layouts y sublayouts.

* **Sprint 3:** Añadir Label al canvas. Aquí se implementará código común para interactuar con los diferentes controles.

* **Sprint 4:** Añadir Button y CheckBox al canvas.

* **Sprint 5:** Añadir EditBox al canvas.

* **Sprint 6:** Poder grabar en disco los diseños. Lista de formularios.

* **Sprint 7:** Object Inspector. Reflejar la jerarquía de objetos en el panel de la derecha.

* **Sprint 8:** Property Editor. Poder editar el objeto seleccionado en el Object Inspector.

* **Sprint 9:** Exportar a Harbour .prg (1). Generar código Harbour compilable a partir del diseño del formulario. Este código reproducirá el formulario en tiempo de ejecución.

* **Sprint 10:** Exportar a Harbour .prg (2). Es posible que esta tarea ocupe dos sprints.

* **Sprint 11:** Integración runtime con Harbour (1). Aquí se definirá una librería para poder interactuar con los formularios en tiempo de ejecución. Por ejemplo:
    ```
    // This function is defined in the .prg
    // automatically generated by GTNAP-Designer
    O_Form := NAP_ASPECT_CUSTOMER_DATA_FORM()

    // These functions are defined in GTNAP-FORMS library
    // and used in the application for interact with the form.
    NAP_FORM_ON_BUTTON_CLICK(O_Form, "button1", {|| ShowMessage("Clicked")})
    NAP_FORM_GET_EDIT_TEXT(O_Form, "editCustomerName", @C_CustomerName)
    ```

* **Sprint 12:** Integración runtime con Harbour (2). Es posible que esta tarea ocupe dos sprints.

## Fase 2: Componentes avanzados

En esta fase ampliaremos el catálogo de widgets. Aprovecharemos la implementación básica para enriquecer los formularios con controles adicionales:

* Control TextView. Para editar textos largos y, opcionalmente, aplicar formatos (Fuente, negrita, tamaños, etc). [Link](https://nappgui.com/en/gui/textview.html).

* Control ImageView. Poder insertar imágenes en los formularios. [Link](https://nappgui.com/en/gui/imageview.html).

* Control TableView. Añadir tablas y configurar sus columnas (ancho, redimensión, cabecera, etc). [Link](https://nappgui.com/en/gui/tableview.html).

* Control TreeView. Añadir a la tabla la capacidad de trabajar con árboles.

* Radio Button. Conjunto de radio botones, donde solo uno de ellos puede estar seleccionado. [Link](https://nappgui.com/en/gui/button.html#h1).

* Control Slider y Progress. [Link](https://nappgui.com/en/gui/slider.html). [Link](https://nappgui.com/en/gui/progress.html).

* Control PopUp. Botón con menú desplegable. [Link](https://nappgui.com/en/gui/popup.html).

* Control ComboBox. Cuadro de edición con menú desplegable. [Link](https://nappgui.com/en/gui/combo.html).

* Control ListBox. Cuadro de lista con iconos y/o checkbox opcionales. [Link](https://nappgui.com/en/gui/listbox.html).

* Control WebView. Vista Web. [Link](https://nappgui.com/en/gui/webview.html).

* Vista de dibujo y vista OpenGL. **Por el momento descartados**. Habría que estudiar como implementar el API de dibujo en Harbour. [Link](https://nappgui.com/en/gui/view.html). [Link](https://nappgui.com/en/ogl3d/ogl3d.html).

### Fase 2: Estimación de Sprints (10)

* **Sprint 1:** Implementación del TextView. Añadir control, añadir soporte al archivo **(.iu)** y al exportador de Harbour.

* **Sprint 2:** Implementación del ImageView. Añadir control, añadir soporte al archivo **(.iu)** y al exportador de Harbour.

* **Sprint 3 y 4:** Implementación del TableView. Añadir control, añadir soporte al archivo **(.iu)** y al exportador de Harbour. Este componente es más complicado de integrar, debido a la configuración de las columnas.

* **Sprint 5:** Radio buttons. Añadir controles, añadir soporte al archivo **(.iu)** y al exportador de Harbour.

* **Sprint 6:** Sliders y progress. Añadir controles, añadir soporte al archivo **(.iu)** y al exportador de Harbour.

* **Sprint 7:** Popup. Añadir control, añadir soporte al archivo **(.iu)** y al exportador de Harbour.

* **Sprint 8:** ComboBox. Añadir control, añadir soporte al archivo **(.iu)** y al exportador de Harbour.

* **Sprint 9:** ListBox. Añadir control, añadir soporte al archivo **(.iu)** y al exportador de Harbour.

* **Sprint 10:** WebView. Añadir control, añadir soporte al archivo **(.iu)** y al exportador de Harbour.

## Fase 3: Funciones avanzadas de edición

Ya con la aplicación lista para crear y editar cualquier tipo de formulario, nos centraremos en mejorar la herramienta de diseño. Las funcionalidades a implementar en esta fase serán:

* Selección múltiple. Poder seleccionar varios objetos con el ratón o pulsando [Ctrl+click].

* Portapapeles: Copy, Paste, Cut.

* Undo/Redo: Capacidad de deshacer y rehacer los cambios.

* Drag'N'Drop. Poder arrastrar widgets desde la vista izquierda al área del canvas y vincularlos con una celda del layout.

* Mejorar iconos.
